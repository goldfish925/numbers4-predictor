
<!DOCTYPE html>

<html lang="ja">

<head>

 <meta charset="UTF-8" />

 <title>NUMBERS4äºˆæƒ³</title>

 <style>

  body {

   font-family: "Hiragino Kaku Gothic ProN", sans-serif;

   background-color: #ffffff;

   color: #5a4635;

   text-align: center;

   padding: 20px;

  }



  h1 {

   font-size: 28px;

   color: #c1a57b; /* ã‚³ã‚³ã‚¢è‰² */

   margin-top: 40px;

  }



  h3 {

   color: #c1a57b;

  }



  button {

   background-color: #c1a57b;

   color: #ffffff;

   padding: 10px 20px;

   border: none;

   border-radius: 8px;

   font-size: 16px;

   cursor: pointer;

   margin-top: 10px;

  }



  .prediction-box {

   background-color: #ffffff; /* â† ç™½èƒŒæ™¯ã«ä¿®æ­£ */

   border: 2px solid #c1a57b;

   border-radius: 12px;

   padding: 15px;

   margin: 20px auto;

   max-width: 320px;

   box-shadow: 0 4px 8px rgba(193, 165, 123, 0.2);

  }



  #predictionList {

   font-size: 1.6em;

   list-style: none;

   padding: 0;

   margin: 0;

  }



  table {

   border-collapse: collapse;

   margin: 0 auto;

   margin-top: 20px;

  }



  th, td {

   border: 1px solid #d8c4a0; /* ãƒŸãƒ«ã‚¯ãƒ†ã‚£ãƒ¼ç³»ã®æ·¡ã„ç·š */

   padding: 6px 10px;

  }



  th {

   background-color: #fdf7f0;

   color: #5a4635;

  }



  td {

   background-color: #fff;

  }



  .neco-image {

   width: 120px;

   margin-bottom: 10px;

  }

  <h3>ãƒœãƒƒã‚¯ã‚¹ä¸€è‡´è¨˜éŒ²</h3>
<table id="boxMatchTable" border="1" style="margin: 20px auto; border-collapse: collapse;">
  <tr>
    <th>æ—¥ä»˜</th>
    <th>å½“é¸ç•ªå·</th>
    <th>äºˆæ¸¬â‘ </th><th>ä¸€è‡´</th>
    <th>äºˆæ¸¬â‘¡</th><th>ä¸€è‡´</th>
    <th>äºˆæ¸¬â‘¢</th><th>ä¸€è‡´</th>
  </tr>
</table>

 </style>

</head>

<body>

 <img src="neco.png" alt="ã­ã“" class="neco-image" />

  

 <div class="prediction-box">

  <h3>ğŸ”®äºˆæ¸¬æ•°å­—ğŸ”®</h3>

  <ul id="predictionList"></ul>

 </div>



 <h1>NUMBERS4äºˆæƒ³</h1>

 <input type="file" id="csvFile" accept=".csv" />

 <button id="predictButton">äºˆæ¸¬é–‹å§‹</button>

 <div id="details"></div>



 <script>

  const wheels = {

   åƒ: [0,3,6,9,2,5,8,1,4,7],

   ç™¾: [0,1,2,3,4,5,6,7,8,9],

   å: [0,7,4,1,8,5,2,9,6,3],

   ä¸€: [0,9,8,7,6,5,4,3,2,1],

  };

  const positions = ['åƒ','ç™¾','å','ä¸€'];



  document.getElementById('predictButton').addEventListener('click', predict);



  function parseCSV(text) {

   return text.trim().split('\n').slice(1).map(line => {

    const cols = line.split(',');

    const date = cols[1].trim();

    const number = cols[2].trim().replace(/[^\d]/g, '').padStart(4,'0');

    return { date, number };

   });

  }



  function getWheelDiffs(prev, curr) {

   if (!prev || !curr || prev.length < 4 || curr.length < 4) return ['','','',''];

   const p = prev.split('').map(Number);

   const c = curr.split('').map(Number);

   return positions.map((pos, i) => {

    const wheel = wheels[pos];

    const pi = wheel.indexOf(p[i]);

    const ci = wheel.indexOf(c[i]);

    const left = (pi - ci + 10) % 10;

    const right = (ci - pi + 10) % 10;

    return (left <= right ? 'å·¦' : 'å³') + Math.min(left, right);

   });

  }



  function predict() {

   const file = document.getElementById('csvFile').files[0];

   if (!file) return alert('CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„');



   const reader = new FileReader();

   reader.onload = e => {

    let data = parseCSV(e.target.result);



    // äºˆæ¸¬æ—¥ï¼ˆæœªæ¥æ—¥ï¼‰ã‚’è¿½åŠ 

    const lastDate = new Date(data[data.length - 1].date);

    lastDate.setDate(lastDate.getDate() + 1);

    while (lastDate.getDay() === 0 || lastDate.getDay() === 6) {

     lastDate.setDate(lastDate.getDate() + 1);

    }

    const yyyy = lastDate.getFullYear();

    const mm = String(lastDate.getMonth() + 1).padStart(2, '0');

    const dd = String(lastDate.getDate()).padStart(2, '0');

    const nextDateStr = `${yyyy}/${mm}/${dd}`;

    data.push({ date: nextDateStr, number: '' });



    const reversedData = [...data].reverse();



    // å·®åˆ†ãƒ†ãƒ¼ãƒ–ãƒ«

    const resultArea = document.getElementById('details');

    resultArea.innerHTML = '';



    const wrapper = document.createElement('div');

    wrapper.style.textAlign = 'center';



    const table = document.createElement('table');

    table.innerHTML = '<tr><th>æ—¥ä»˜</th><th>ç•ªå·</th><th>åƒ</th><th>ç™¾</th><th>å</th><th>ä¸€</th></tr>';



    const future = reversedData[0];

    const futureTr = document.createElement('tr');

    futureTr.style.backgroundColor = '#eef';

    futureTr.innerHTML = `<td>${future.date}</td><td></td><td></td><td></td><td></td><td></td>`;

    table.appendChild(futureTr);



    for (let i = 1; i < reversedData.length; i++) {

     const current = reversedData[i];

     const prev = reversedData[i - 1];



     const diffs = (current.number && prev?.number)

      ? getWheelDiffs(current.number, prev.number)

      : ['', '', '', ''];



     const tr = document.createElement('tr');

     const diffTds = diffs.map(d => {

      const color = d.startsWith('å³') ? 'red' : d.startsWith('å·¦') ? 'green' : 'black';

      return `<td style="color:${color}">${d}</td>`;

     });

     // ä¸€è‡´æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆï¼ˆãƒœãƒƒã‚¯ã‚¹å½¢å¼ã§ï¼‰
function countBoxMatch(pred, actual) {
  const p = pred.split('');
  const a = actual.split('');
  let count = 0;
  const used = Array(4).fill(false);
  for (let i = 0; i < p.length; i++) {
    for (let j = 0; j < a.length; j++) {
      if (!used[j] && p[i] === a[j]) {
        count++;
        used[j] = true;
        break;
      }
    }
  }
  return count;
}

// è¡¨ã‚’ä½œæˆãƒ»æ›´æ–°
const history = document.getElementById('boxMatchTable');
const row = document.createElement('tr');
const actual = latestNumber; // äºˆæ¸¬æ—¥ã®å‰æ—¥ãŒå½“é¸ç•ªå·
const counts = predictions.map(p => countBoxMatch(p, actual));
row.innerHTML = `
  <td>${nextDateStr}</td>
  <td>${actual}</td>
  <td>${predictions[0]}</td><td>${counts[0]}å€‹</td>
  <td>${predictions[1]}</td><td>${counts[1]}å€‹</td>
  <td>${predictions[2]}</td><td>${counts[2]}å€‹</td>
`;
history.appendChild(row);



     tr.innerHTML = `<td>${current.date}</td><td>${current.number}</td>${diffTds.join('')}`;

     table.appendChild(tr);

    }



    wrapper.appendChild(table);

    resultArea.appendChild(wrapper);



    // ===== äºˆæ¸¬ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆ3ã‚¹ã‚¿ã‚¤ãƒ«ï¼‰ =====

    function getIndexDiffStats(data) {

     const diffStats = { åƒ: {}, ç™¾: {}, å: {}, ä¸€: {} };



     for (let i = 1; i < data.length; i++) {

      const prev = data[i - 1].number;

      const curr = data[i].number;

      if (!prev || !curr) continue;



      positions.forEach((pos, j) => {

       const wheel = wheels[pos];

       const pi = wheel.indexOf(Number(prev[j]));

       const ci = wheel.indexOf(Number(curr[j]));

       if (pi === -1 || ci === -1) return;



       const right = (ci - pi + 10) % 10;

       const left = (pi - ci + 10) % 10;

       const diff = (left <= right) ? -left : right;



       diffStats[pos][diff] = (diffStats[pos][diff] || 0) + 1;

      });

     }



     return diffStats;

    }



    function generateTopPredictions(latestNumber, diffStats, count = 3) {

     const candidates = [];



     for (let k = 0; k < count; k++) {

      const predictedDigits = positions.map((pos, i) => {

       const wheel = wheels[pos];

       const digit = Number(latestNumber[i]);

       const currentIndex = wheel.indexOf(digit);

       if (currentIndex === -1) return digit;



       const diffs = diffStats[pos];

       const sorted = Object.entries(diffs)

        .sort((a, b) => b[1] - a[1])

        .map(([d]) => parseInt(d));



       const diff = sorted[k] ?? 0;

       const newIndex = (currentIndex + diff + 10) % 10;

       return wheel[newIndex];

      });



      candidates.push(predictedDigits.join(''));

     }



     return [...new Set(candidates)];

    }



    const diffStats = getIndexDiffStats(data.slice(1));

    const latestNumber = data[data.length - 2].number;

    const predictions = generateTopPredictions(latestNumber, diffStats, 3);



    const predictionList = document.getElementById('predictionList');

    predictionList.innerHTML = '';

    predictions.forEach(num => {

     const li = document.createElement('li');

     li.textContent = `ğŸ¦‰ ${num}`;

     predictionList.appendChild(li);

    });

   };



   reader.readAsText(file);

  }

 </script>

</body>

</html>
